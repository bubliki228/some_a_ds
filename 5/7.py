arr = [7, -9, 3, 4, -7, 8]

#Данный алгоритм заключается в том, чтобы создать вспомогательный
#логический массив, которйы будет проверять, встречалось ли данное число или нет
#Для этог надо найти максимальное и минимальное значения (сложность - O(n))
#Пройтись по изначальному массиву для построения вспомогательного (сожность O(n))
#Далее пройтись по вспомогательному массиву в поисках первого не найденного числа (сложность O(n))
#Временная сложность O(4n), отбрасываем константу и получаем O(n)
#Сложность по памяти - O(n), так как требуется построение нового массива такой же 
#длины, как и изначальный


max_num = max(arr)  # Находим максимальное значение в массиве
min_num = min(arr)  # Находим минимальное значение в массиве

check_arr = [False for i in range(max_num - min_num + 1)]  # Создаем вспомогательный логический массив

for i in arr:
    check_arr[i - min_num] = True  # Устанавливаем флаг True для каждого числа из изначального массива

for i in range(len(check_arr)):
    if check_arr[i] == False:
        print("Минимально пропущенное: ", i + min_num)
        break  # Находим первое не найденное число и выводим его
